package de.tu_bs.cs.isf.e4cf.parser.antlr.grammar_check;

import java.lang.reflect.InvocationTargetException;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.TokenStream;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;

/**
 * Grammar Check main application.
 * Start a windowed application with a specific lexer and parser. 
 * 
 * @author Oliver Urbaniak
 *
 */
public class GrammarCheckApplication {

	/**
	 * Starts a windowed Grammar Check application specialized by the  
	 * provided concrete lexer and parser as generated by ANTLR.
	 * 
	 * @param <L> type extending {@link org.antlr.v4.runtime.Lexer}
	 * @param <P> type extending {@link org.antlr.v4.runtime.parser}
	 * @param lexerClazz class object for the specific lexer type
	 * @param parserClazz class object for the specific parser type
	 * @param winSize window size in pixels
	 */
	public static <L extends Lexer, P extends Parser> void start(Class<L> lexerClazz, Class<P> parserClazz, Point winSize) {
		Display display = new Display();
		Shell shell = new Shell(display);
		shell.setText("Grammar Check");
		shell.setLayout(new GridLayout(1, true));
		shell.setSize(winSize.x, winSize.y);
		
		
		// initialize logic
		try {
			L lexer = newLexer(lexerClazz);
			P parser = newParser(parserClazz);
			
			GrammarCheckController<L, P> controller = new GrammarCheckController<L, P>(lexer, parser);
			controller.createView(shell);
			controller.attachViewBehaviour();
		} catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
			e.printStackTrace();
			return;
		}
				
		// run the event loop as long as the window is open
		shell.open();
		while (!shell.isDisposed()) {
		    if (!display.readAndDispatch()) {
		        display.sleep();
		     }
		}
	
		// disposes all associated windows and their components
		display.dispose();
	}

	private static <L extends Lexer> L newLexer(Class<L> lexerClazz)
			throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
		return lexerClazz.getConstructor(CharStream.class).newInstance(new Object[] {null});
	}
	
	private static <P extends Parser> P newParser(Class<P> parserClazz)
			throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
		return parserClazz.getConstructor(TokenStream.class).newInstance(new Object[] {null});
	}
}
